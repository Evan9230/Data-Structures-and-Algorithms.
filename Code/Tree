// 二叉树的链式存储结构
typedef struct BiTNode {
    ElemType data;                    // 数据域
    struct BiTNode *lchild, *rchild;  // 左、右孩子指针
} BiTNode, *BiTree;

//先序遍历先序遍历 (PreOrder) 的操作过程如下。​​
//若二叉树为空，则什么也不做；否则，
//访问根结点；
//先序遍历左子树；
//先序遍历右子树。
void PreOrder(BiTree T) {
    if (T != NULL) {
        visit(T);              // 访问根结点
        PreOrder(T->lchild);   // 递归遍历左子树
        PreOrder(T->rchild);   // 递归遍历右子树
    }
}


//中序遍历
void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->lchild);   // 递归遍历左子树
        visit(T);             // 访问根结点
        InOrder(T->rchild);   // 递归遍历右子树
    }
}

//后序遍历
void PostOrder(BiTree T) {
    if (T != NULL) {
        PostOrder(T->lchild);   // 递归遍历左子树
        PostOrder(T->rchild);   // 递归遍历右子树
        visit(T);              // 访问根结点
    }
}

//中序遍历非递归
void InOrder2(BiTree T) {
    InitStack(S); 
    BiTree p = T;        //初始化栈S; p是遍历指针
    
    while (p || !IsEmpty(S)) {    //栈不空或p不空时循环
        if (p) {                  //一路向左
            Push(S, p);          //当前结点入栈
            p = p->lchild;       //左孩子不空，一直向左走
        }
        else {                    //出栈，并转向出栈结点的右子树
            Pop(S, p); 
            visit(p);            //栈顶元素出栈，访问出栈结点
            p = p->rchild;       //向右子树走，p赋值为当前结点的右孩子
        }
    }                           //返回while循环继续进入if-else语句
}


//先序遍历非递归
void PreOrder2(BiTree T) {
    InitStack(S); 
    BiTree p = T;        //初始化栈S；p是遍历指针
    
    while (p || !IsEmpty(S)) {    //栈不空或p不空时循环
        if (p) {                  //一路向左
            visit(p); 
            Push(S, p);          //访问当前结点，并入栈
            p = p->lchild;       //左孩子不空，一直向左走
        }
        else {                    //出栈，并转向出栈结点的右子树
            Pop(S, p);           //栈顶元素出栈
            p = p->rchild;       //向右子树走，p赋值为当前结点的右孩子
        }
    }                           //返回while循环继续进入if-else语句
}

//二叉树层次遍历
void LevelOrder(BiTree T) {
    InitQueue(Q);             //初始化辅助队列
    BiTree p;
    EnQueue(Q, T);           //将根结点入队
    
    while (!IsEmpty(Q)) {     //队列不空则循环
        DeQueue(Q, p);       //队头结点出队
        visit(p);            //访问出队结点
        
        if (p->lchild != NULL)
            EnQueue(Q, p->lchild);  //左子树不空，则左子树根结点入队
        if (p->rchild != NULL)
            EnQueue(Q, p->rchild);  //右子树不空，则右子树根结点入队
    }
}