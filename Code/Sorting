//冒泡排序
void BubbleSort(ElemType A[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool flag = false; // 表示本趟冒泡是否发生交换的标志
        
        for (int j = n - 1; j > i; j--) { // 一趟冒泡过程
            if (A[j - 1] > A[j]) {        // 若为逆序
                swap(A[j - 1], A[j]);     // 交换
                flag = true;
            }
        }
        
        if (flag == false)
            return; // 本趟遍历后没有发生交换，说明表已经有序
    }
}




//直接插入排序 
void InsertSort(ElemType A[], int n) {
    int i, j;
    
    for (i = 2; i <= n; i++) {      // 依次将A[2]~A[n]插入前面已排序序列
        if (A[i] < A[i - 1]) {         // 若A[i]关键码小于其前驱，将A[i]插入有序表
            A[0] = A[i];               // 复制为哨兵，A[0]不存放元素
            
            for (j = i - 1; A[0] < A[j]; --j)  // 从后往前查找待插入位置
                A[j + 1] = A[j];         // 向后挪位
            
            A[j + 1] = A[0];           // 复制到插入位置
        }
    }
}

//折半插入排序
void InsertSort(ElemType A[], int n) {
    int i, j, low, high, mid;
    
    for (i = 2; i <= n; i++) {
        A[0] = A[i];                    // 将A[i]暂存到A[0]
        low = 1; high = i - 1;          // 设置折半查找的范围
        
        while (low <= high) {           // 折半查找（默认递增有序）
            mid = (low + high) / 2;     // 取中间点
            if (A[mid] > A[0]) 
                high = mid - 1;         // 查找左半子表
            else 
                low = mid + 1;          // 查找右半子表
        }
        
        for (j = i - 1; j >= high + 1; --j) {
            A[j + 1] = A[j];            // 统一后移元素，空出插入位置
        }
        A[high + 1] = A[0];             // 插入操作
    }
}

//希尔排序
void ShellSort(ElemType A[], int n) {
    // A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
    int dk, i, j;
    
    for (dk = n/2; dk >= 1; dk = dk/2) {        // 增量变化（无统一规定）
        for (i = dk+1; i <= n; ++i) {
            if (A[i] < A[i-dk]) {               // 需将A[i]插入有序增量子表
                A[0] = A[i];                    // 暂存在A[0]
                
                for (j = i-dk; j > 0 && A[0] < A[j]; j -= dk) {
                    A[j+dk] = A[j];             // 记录后移，查找插入的位置
                }
                A[j+dk] = A[0];                // 插入
            }//if
        }
    }
}