//栈定义类型&初始化
#define MaxSize 50        //定义栈中元素的最大个数
typedef struct {
    Elemtype data[MaxSize];  //存放栈中元素
    int top;                 //栈顶指针
} SqStack;
void InitStack(SqStack &S)
{
    S.top = -1;
}

//栈空判断
bool StackEmpty(SqStack S)
{ 
    if (S.top == -1)//栈空
        return true;
    else
        return false;
}


//进栈操作
bool Push(SqStack &S, ElemType x) 
{
    if (S.top == Maxsize - 1) //栈满
        return false;
    S.data[++S.top] = x return ture;
}

//出栈操作
bool Pop(SqStack &S, ElemType x)
{
    if (S.top == -1) //栈空
        return false;
    S.data[S.top--] = x return ture;
}

//读栈顶
bool GetTop(SqStack S, ElemType x)
{
    if (S.top == -1)//栈空
        return false;
    x = S.data[S.top] return ture;
}


//共享栈入栈
int Pop(shareStack *ss,int flag){
    if(flag == 1){
        if(ss->top1 == -1)
            return -1;
        return ss->data[ss->top1--];
    }else if(flag == 2){
        if(ss->top2 == MAXSIZE)
            return -1;
        return ss->data[ss->top2++];
    }
    return -1;
}


//共享栈出栈
int Push(shareStack *ss,int num,int flag){
    if(ss->top1+1 == ss->top2)
        return 0;
    if(flag == 1){
        ss->data[++ss->top1] = num;
        return 1;
    }else if( flag == 2){
        ss->data[--ss->top2] = num;
        return 1;
    }
    return 0;
}

//栈的链式存储类型
typedef struct Linknode{
    ElemType data;        //数据域
    struct Linknode *next; //指针域
} *LiStack;               //栈类型定义

//链栈的初始化
Status InitStack(LinkStack &S)
{//构￿造一个空栈S￿，栈￿顶指￿针置空
 S=NULL;
 return OK;
}

//链栈的入栈
Status Push(LinkStack &S, SElemType e) 
{//在栈顶插入元素e
 p=new StackNode; //生成新结点
 p->data=e; //将新结点数据域置为e
 p->next=S; //将新结点插入栈顶
 S=p; //修改栈￿顶指针为p
 return OK;
}


//￿链栈的出栈
Status Pop(LinkStack &S,SElemType &e)
{//删除S的栈顶元素，用e返回其值
 if(S==NULL) return ERROR; //栈空
 e=S->data; //将栈顶元素￿赋给e
 p=S; //用p临时保存栈￿顶元素空间，以备释放
 S=S->next; //修改栈顶指￿针
 delete p; //释放原栈￿顶元素的空￿间
 return OK;
}

//取链栈的栈顶元素
SElemType GetTop(LinkStack S)
{//返回S的栈￿顶元素，不修改栈顶指针
 if(S!=NULL) //栈非空
　　　return S->data; //返回栈顶元素的值￿，栈顶指针不变
}

//队列顺序存储类型&初始化
#define MaxSize 50
typedef struct
{
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;
void InitQueue(SqQueue &Q)
{
    Q.rear = Q.front = 0;
}



//普通队列队空&队满判断
Q.front == Q.rear == 0 //判断队空
Q.rear == MaxSize && Q.front == 0 //判断队满

//循环队列入队
bool EnEmpty(SqQueue &Q, ElemType x)
{
    if ((Q.rear + 1) % MaxSize == Q.front)
        return false;
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MaxSize;
    return true;
}

//循环队列出队  
bool DeEmpty(SqQueue &Q, ElemType &x)
{
    if (Q.rear == Q.front)
        return false;
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    return true;
}

//循环队列判断对空
bool isEmpty(SqQueue Q)
{
    if (Q.rear == Q.front)
        return true;
    else
        return false;
}

//循环队列
Q.front == (Q.rear+1)%MaxSize //队满
Q.front == Q.rear//队空
(Q.rear - Q.front + MaxSize)%MaxSize //队列长度

//队的链式存储（​​Linked Queue）
typedef struct LinkNode
{
    ElemType data;
    struct LinkNode *next;
} LinkNode;
typedef struct
{
    LinkNode *front, *rear;
} LinkNode;
void InitQueue(LinkQueue &Q)
{
    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}
//队空判断
bool isEmpty(LinkQueue Q)
{
    if (Q.rear == Q.front)
        return true;
    else
        return false;
}

//Enqueue operation
bool EnEmpty(LinkQueue &Q, ElemType x)
{
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;
    Q.rear = s;
}

//Dequeue Operation
bool DeEmpty(LinkQueue &Q, ElemType &x)
{
    if (Q.rear == Q.front)
        return false;
    LinkNode *p = Q.front->next;
    x = p->data;
    Q.front->next = p->next 
    if (Q.rear == p)
        Q.rear = Q.front;
    free(p);
    return true;
}

