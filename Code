头插法建立单链表
LinkList List_HeadInsert(LinkList &L) {  //逆向建立单链表
    LNode *s; int x;
    L=(LinkList)malloc(sizeof(LNode));  //创建头结点
    L->next=NULL;                       //初始为空链表
    scanf("%d",&x);                     //输入结点的值
    while(x!=9999){                     //输入9999表示结束
        s=(LNode*)malloc(sizeof(LNode));//创建新结点
        s->data=x;
        s->next=L->next;
        L->next=s;                      //将新结点插入表中，L为头指针
        scanf("%d",&x);
    }
    return L;
}

头插法建立单链表
LinkList List_TailInsert(LinkList &L) {  //正向建立单链表
    int x;                              //设元素类型为整型
    L=(LinkList)malloc(sizeof(LNode));  //创建头结点
    LNode *s,*r=L;                      //r为表尾指针
    scanf("%d",&x);                     //输入结点的值
    while(x!=9999) {                    //输入9999表示结束
        s=(LNode *)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;                            //r指向新的表尾节点
        scanf("%d",&x);
    }
    r->next=NULL;                       //尾结点指针置空
    return L;
}

单链表按序号查找结点
LNode *GetElem(LinkList L,int i){
    if(i<1) return NULL; //若i无效，则返回NULL
    int j=1; //计数，初始为1
    LNode *p=L->next; //第1个结点指针赋给p
    while(p!=NULL&&j<i){ //从第1个结点开始找，查找第i个结点
        p=p->next;
        j++;
    } //注意：原图代码此处缺少循环体右大括号，这里已补全
    return p; //返回第i个结点的指针，若i大于表长，则返回NULL
}