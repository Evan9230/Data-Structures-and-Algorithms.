//头插法建立单链表
LinkList List_HeadInsert(LinkList &L) {  //逆向建立单链表
    LNode *s; int x;
    L=(LinkList)malloc(sizeof(LNode));  //创建头结点
    L->next=NULL;                       //初始为空链表
    scanf("%d",&x);                     //输入结点的值
    while(x!=9999){                     //输入9999表示结束
        s=(LNode*)malloc(sizeof(LNode));//创建新结点
        s->data=x;
        s->next=L->next;
        L->next=s;                      //将新结点插入表中，L为头指针
        scanf("%d",&x);
    }
    return L;
}


//尾插法建立单链表
LinkList List_TailInsert(LinkList &L) {  //正向建立单链表
    int x;                              //设元素类型为整型
    L=(LinkList)malloc(sizeof(LNode));  //创建头结点
    LNode *s,*r=L;                      //r为表尾指针
    scanf("%d",&x);                     //输入结点的值
    while(x!=9999) {                    //输入9999表示结束
        s=(LNode *)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;                            //r指向新的表尾节点
        scanf("%d",&x);
    }
    r->next=NULL;                       //尾结点指针置空
    return L;
}

//单链表按序号查找结点
LNode *GetElem(LinkList L,int i){
    if(i<1) return NULL; //若i无效，则返回NULL
    int j=1; //计数，初始为1
    LNode *p=L->next; //第1个结点指针赋给p
    while(p!=NULL&&j<i){ //从第1个结点开始找，查找第i个结点
        p=p->next;
        j++;
    } 
    return p; //返回第i个结点的指针，若i大于表长，则返回NULL
}

//单链表按位置插入节点
Status ListInsert(LinkList &L, int i, ElemType e) {
    // 在带头节点的单链表L中第i个位置插入值为e的新节点
    p = L;
    j = 0;
    while (p && (j < i - 1)) {
        p = p->next;
        ++j;
    } 
    // 查找第i-1个结点，p指向该结点
    if (!p || j > i - 1) { // 非空或i<1
        return ERROR;
    } 
    // i > n+1或者i < 1
    s = new LNode; 
    // 生成新结点*s
    s->data = e; 
    // 将结点*s的数据域置为e
    s->next = p->next; 
    // 将结点*s的指针域指向结点a_i
    p->next = s; 
    // 将结点*p的指针域指向结点*s
    return OK;
}


//按值查找表节点
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p != NULL && p->data != e)  // 从第1个结点开始查找data域为e的结点
        p = p->next;
    return p;                          // 找到后返回该结点指针，否则返回NULL
}

// 带头结点单链表删除元素e
typedef struct LNode {
    int data;           // 数据域（存储整数）
    struct LNode *next; // 指针域（指向后继节点）
} LNode, *LinkList;     // LNode为节点类型，LinkList为指针类型

// 函数：删除单链表中值为e的节点（假定该节点一定存在）
void Delete_e(LinkList L, int e) {
    LNode *p = L->next; // p指向第一个数据节点
    LNode *pre = L;     // pre指向头结点（前驱指针）
    LNode *q;           // 暂存待删除节点

    while (p != NULL) { // 遍历链表
        if (p->data == e) { // 找到目标节点
            q = p;          // 暂存待删除节点
            p = p->next;    // p移动到下一个节点
            pre->next = p;  // 前驱节点跳过待删除节点
            free(q);        // 释放内存
        } else { // 未找到，继续遍历
            pre = p;        // 前驱指针跟随p移动
            p = p->next;    // p向后移动
        }
    }
}

// 插入节点（前插）
p=GetElem(L,i-1); //查找插入位置的前驱结点
s->next=p->next; //图2.7中操作步骤1
p->next=s; //图2.7中操作步骤2

//后插节点
s->next=p->next; //修改指针域，不能颠倒
p->next=s;
temp=p->data; //交换数据域部分
p->data=s->data;
s->data=temp;

//删除节点
p=GetElem(L,i-1); //查找删除位置的前驱结点
q=p->next; //令q指向被删除结点
p->next=q->next; //将*q结点从链中"断开"
free(q); //释放结点的存储空间


//双链表
typedef struct DNode{  //定义双链表结点类型
    ElemType data;  //数据域
    struct DNode *prior,*next;  //前驱和后继指针
}DNode, *DLinklist;

//双链表插入
s->next=p->next;     //将结点*s插入到结点*p之后
p->next->prior=s;
s->prior=p;
p->next=s;

//双链表删除
p->next=q->next;     //图2.11中步骤①
q->next->prior=p;     //图2.11中步骤②
free(q);             //释放结点空间
